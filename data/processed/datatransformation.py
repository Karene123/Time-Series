# -*- coding: utf-8 -*-
"""DataTransformation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/115-l7PCMk9zlNjG1bKQDeAVSigt9oLUR

# Linear Interpolation
"""

# Resample the columns
cols = ['M2V', 'GDPC1']
# Resample each column separately (interpolation)
for col in cols:
    data_sliced[col] = data_sliced[col].interpolate()

print(data_sliced)

data_sliced.describe()

# Distribution of CPI varible (right skewed)
fig1 = px.histogram(data_sliced, x='CPIAUCSL')
fig1.show()

# Distribution of FEDFUNDS variable (right skewed)
fig2 = px.histogram(data_sliced, x='FEDFUNDS')
fig2.show()

# Distribution of M2SL variable (right skewed)
fig3 = px.histogram(data_sliced, x='M2SL')
fig3.show()

# Distribution of M2V	 variable (right skewed)
fig4 = px.histogram(data_sliced, x='M2V')
fig4.show()

# Distribution of GDPC1 variable (right skewed)
fig5 = px.histogram(data_sliced, x='GDPC1')
fig5.show()



"""# Data Diagnosis"""

CPIAUCSL_cyclic, CPIAUCSL_trend = hpfilter(data_sliced['CPIAUCSL'])

fig, ax = plt.subplots(1,2, figsize=(16, 4))
CPIAUCSL_cyclic.plot(ax=ax[0], title='CPIAUCSL Cyclic Component')
CPIAUCSL_trend.plot(ax=ax[1], title='CPIAUCSL Trend Component')
plt.show()

FEDFUNDS_cyclic, FEDFUNDS_trend = hpfilter(data_sliced['FEDFUNDS'])

fig, ax = plt.subplots(1,2, figsize=(16, 4))
FEDFUNDS_cyclic.plot(ax=ax[0], title='FEDFUNDS Cyclic Component')
FEDFUNDS_trend.plot(ax=ax[1], title='FEDFUNDS Trend Component')
plt.show()

M2SL_cyclic, M2SL_trend = hpfilter(data_sliced['M2SL'])

fig, ax = plt.subplots(1,2, figsize=(16, 4))
M2SL_cyclic.plot(ax=ax[0], title='M2SL Cyclic Component')
M2SL_trend.plot(ax=ax[1], title='M2SL Trend Component')
plt.show()

M2V_cyclic, M2V_trend = hpfilter(data_sliced['M2V'])

fig, ax = plt.subplots(1,2, figsize=(16, 4))
M2V_cyclic.plot(ax=ax[0], title='M2V Cyclic Component')
M2V_trend.plot(ax=ax[1], title='M2V Trend Component')
plt.show()

GDP_cyclic, GDP_trend = hpfilter(data_sliced['GDPC1'])

fig, ax = plt.subplots(1,2, figsize=(16, 4))
GDP_cyclic.plot(ax=ax[0], title='GDPC1 Cyclic Component')
GDP_trend.plot(ax=ax[1], title='GDPC1 Trend Component')
plt.show()



"""# In depth Analysis
As we can observe, our variables contain trends and need to be transformed.
"""

# Splitting the data between training and testing
data_train = data_sliced.loc[:'2020']
data_test = data_sliced.loc['2021':]
data_train.index

scale = StandardScaler()
scale.fit(data_train)

datatrain_sc = pd.DataFrame(scale.transform(data_train),
                            index=data_train.index,
                              columns=data_train.columns)

datatest_sc = pd.DataFrame(scale.transform(data_test),
                           index=data_test.index,
                             columns=data_test.columns)

data_test[0:5]

datatrain_sc

# Plot on the same scale
datatrain_sc.plot()
plt.show()

# function to print results
def print_results(output, test='adf'):

    test_score = output[0]
    pval = output[1]
    lags = output[2]

    decision = 'Non-Stationary'
    if test == 'adf':
        critical = output[4]
        if pval < 0.05:
            decision = 'Stationary'
    elif test=='kpss':
        critical = output[3]
        if pval >= 0.05:
            decision = 'Stationary'

    output_dict = {
    'Test Statistic': test_score,
    'p-value': pval,
    'Numbers of lags': lags,
    'decision': decision
    }
    for key, value in critical.items():
        output_dict["Critical Value (%s)" % key] = value

    return pd.Series(output_dict, name=test)

adf_output = adfuller(datatrain_sc['CPIAUCSL'])
kpss_output = kpss(datatrain_sc['CPIAUCSL'])

pd.concat([print_results(adf_output, 'adf'), print_results(kpss_output, 'kpss')], axis=1)

adf_output = adfuller(datatrain_sc['FEDFUNDS'])
kpss_output = kpss(datatrain_sc['FEDFUNDS'])

pd.concat([print_results(adf_output, 'adf'), print_results(kpss_output, 'kpss')], axis=1)

adf_output = adfuller(datatrain_sc['GDPC1'])
kpss_output = kpss(datatrain_sc['GDPC1'])

pd.concat([print_results(adf_output, 'adf'), print_results(kpss_output, 'kpss')], axis=1)

adf_output = adfuller(datatrain_sc['M2SL'])
kpss_output = kpss(datatrain_sc['M2SL'])

pd.concat([print_results(adf_output, 'adf'), print_results(kpss_output, 'kpss')], axis=1)

adf_output = adfuller(datatrain_sc['M2V'])
kpss_output = kpss(datatrain_sc['M2V'])

pd.concat([print_results(adf_output, 'adf'), print_results(kpss_output, 'kpss')], axis=1)

# set up a generalized function for the plot labels
def check_stationarity(df):
    kps = kpss(df)
    adf = adfuller(df)

    kpss_pv, adf_pv = kps[1], adf[1]
    kpssh, adfh = 'Stationary', 'Non-stationary'

    if adf_pv < 0.05:
        # Reject ADF Null Hypothesis
        adfh = 'Stationary'
    if kpss_pv < 0.05:
        # Reject KPSS Null Hypothesis
        kpssh = 'Non Stationary'
    return (kpssh, adfh)

#  set up the comparison plotting function
def plot_comparison(methods, plot_type='line'):
    n = len(methods) // 2
    fig, ax = plt.subplots(n,2, sharex=True, figsize=(20,10))
    for i, method in enumerate(methods):
        method.dropna(inplace=True)
        name = [n for n in globals() if globals()[n] is method]
        v, r = i // 2, i % 2

        kpss_s, adf_s = check_stationarity(method)

        method.plot(kind=plot_type,
                    ax=ax[v,r],
                    legend=False,
                    title=f'{name[0].upper()} KPSS={kpss_s}, ADF={adf_s}')
        ax[v,r].title.set_size(14)
        method.rolling(52).mean().plot(ax=ax[v,r], legend=False)

# using first order differencing (detrending)
first_ord_diff_CPI = datatrain_sc['CPIAUCSL'].diff().dropna()

# using second order differencing
second_ord_diff_CPI = datatrain_sc['CPIAUCSL'].diff().diff().dropna()

# differencing to remove seasonality
diseasonalize_CPI = datatrain_sc['CPIAUCSL'].diff(52).dropna()

# using rolling mean
rolling_mean_CPI = datatrain_sc['CPIAUCSL'].rolling(window=52).mean()
subt_roll_mean_CPI = datatrain_sc['CPIAUCSL'] - rolling_mean_CPI

# log transform
log_transform_CPI = np.log(datatrain_sc['CPIAUCSL'])

# Square root transform
square_root_CPI = np.sqrt(datatrain_sc['CPIAUCSL'])

# using seasonal_decompose to remove trend
decomp_CPI = seasonal_decompose(datatrain_sc['CPIAUCSL'])
sd_detrend_CPI = (decomp_CPI.observed - decomp_CPI.trend)

# using hp_filter
cyclic_extract_CPI, trend_CPI = hpfilter(datatrain_sc['CPIAUCSL'])

# combine the methods into a list
methods_CPI = [first_ord_diff_CPI, second_ord_diff_CPI,
           diseasonalize_CPI, subt_roll_mean_CPI,
           log_transform_CPI, square_root_CPI,
           sd_detrend_CPI, cyclic_extract_CPI]

plot = plot_comparison(methods_CPI)
plt.show()
#warnings.simplefilter(action='ignore')

# using first order differencing (detrending)
first_ord_diff_FED = datatrain_sc['FEDFUNDS'].diff().dropna()

# using second order differencing
second_ord_diff_FED = datatrain_sc['FEDFUNDS'].diff().diff().dropna()

# differencing to remove seasonality
diseasonalize_FED = datatrain_sc['FEDFUNDS'].diff(52).dropna()

# using rolling mean
rolling_mean_FED = datatrain_sc['FEDFUNDS'].rolling(window=52).mean()
subt_roll_mean_FED = datatrain_sc['FEDFUNDS'] - rolling_mean_FED

# log transform
log_transform_FED = np.log(datatrain_sc['FEDFUNDS'])

# Square root transform
square_root_FED = np.sqrt(datatrain_sc['FEDFUNDS'])

# using seasonal_decompose to remove trend
decomp_FED = seasonal_decompose(datatrain_sc['FEDFUNDS'])
sd_detrend_FED = (decomp_FED.observed - decomp_FED.trend)

# using hp_filter
cyclic_extract_FED, trend_FED = hpfilter(datatrain_sc['FEDFUNDS'])

# combine the methods into a list
methods_FED = [first_ord_diff_FED, second_ord_diff_FED,
           diseasonalize_FED, subt_roll_mean_FED,
           log_transform_FED, square_root_FED,
           sd_detrend_FED, cyclic_extract_FED]

plot = plot_comparison(methods_FED)
plt.show()
#warnings.simplefilter(action='ignore')

# using first order differencing (detrending)
first_ord_diff_GDP = datatrain_sc['GDPC1'].diff().dropna()

# using second order differencing
second_ord_diff_GDP = datatrain_sc['GDPC1'].diff().diff().dropna()

# differencing to remove seasonality
diseasonalize_GDP = datatrain_sc['GDPC1'].diff(52).dropna()

# using rolling mean
rolling_mean_GDP = datatrain_sc['GDPC1'].rolling(window=52).mean()
subt_roll_mean_GDP = datatrain_sc['GDPC1'] - rolling_mean_GDP

# log transform
log_transform_GDP = np.log(datatrain_sc['GDPC1'])

# Square root transform
square_root_GDP = np.sqrt(datatrain_sc['GDPC1'])

# using seasonal_decompose to remove trend
decomp_GDP = seasonal_decompose(datatrain_sc['GDPC1'])
sd_detrend_GDP = (decomp_GDP.observed - decomp_GDP.trend)

# using hp_filter
cyclic_extract_GDP, trend_GDP = hpfilter(datatrain_sc['GDPC1'])

# combine the methods into a list
methods_GDP = [first_ord_diff_GDP, second_ord_diff_GDP,
           diseasonalize_GDP, subt_roll_mean_GDP,
           log_transform_GDP, square_root_GDP,
           sd_detrend_GDP, cyclic_extract_GDP]

plot = plot_comparison(methods_GDP)
plt.show()
#warnings.simplefilter(action='ignore')

# using first order differencing (detrending)
first_ord_diff_M2L = datatrain_sc['M2SL'].diff().dropna()

# using second order differencing
second_ord_diff_M2L = datatrain_sc['M2SL'].diff().diff().dropna()

# differencing to remove seasonality
diseasonalize_M2L = datatrain_sc['M2SL'].diff(52).dropna()

# using rolling mean
rolling_mean_M2L = datatrain_sc['M2SL'].rolling(window=52).mean()
subt_roll_mean_M2L = datatrain_sc['M2SL'] - rolling_mean_M2L

# log transform
log_transform_M2L = np.log(datatrain_sc['M2SL'])

# Square root transform
square_root_M2L = np.sqrt(datatrain_sc['M2SL'])

# using seasonal_decompose to remove trend
decomp_M2L = seasonal_decompose(datatrain_sc['M2SL'])
sd_detrend_M2L = (decomp_M2L.observed - decomp_M2L.trend)

# using hp_filter
cyclic_extract_M2L, trend_M2L = hpfilter(datatrain_sc['M2SL'])

# combine the methods into a list
methods_M2L = [first_ord_diff_M2L, second_ord_diff_M2L,
           diseasonalize_M2L, subt_roll_mean_M2L,
           log_transform_M2L, square_root_M2L,
           sd_detrend_M2L, cyclic_extract_M2L]

plot = plot_comparison(methods_M2L)
plt.show()
#warnings.simplefilter(action='ignore')

# using first order differencing (detrending)
first_ord_diff_M2V = datatrain_sc['M2V'].diff().dropna()

# using second order differencing
second_ord_diff_M2V = datatrain_sc['M2V'].diff().diff().dropna()

# differencing to remove seasonality
diseasonalize_M2V = datatrain_sc['M2V'].diff(52).dropna()

# using rolling mean
rolling_mean_M2V = datatrain_sc['M2V'].rolling(window=52).mean()
subt_roll_mean_M2V = datatrain_sc['M2V'] - rolling_mean_M2V

# log transform
log_transform_M2V = np.log(datatrain_sc['M2V'])

# Square root transform
square_root_M2V = np.sqrt(datatrain_sc['M2V'])

# using seasonal_decompose to remove trend
decomp_M2V = seasonal_decompose(datatrain_sc['M2V'])
sd_detrend_M2V = (decomp_M2V.observed - decomp_M2V.trend)

# using hp_filter
cyclic_extract_M2V, trend_M2V = hpfilter(datatrain_sc['M2V'])

# combine the methods into a list
methods_M2V = [first_ord_diff_M2V, second_ord_diff_M2V,
           diseasonalize_M2V, subt_roll_mean_M2V,
           log_transform_M2V, square_root_M2V,
           sd_detrend_M2V, cyclic_extract_M2V]

plot = plot_comparison(methods_M2V)
plt.show()
#warnings.simplefilter(action='ignore')

# Transform all columns to second order difference
datatrain_sc = datatrain_sc.diff().diff().dropna()

# Show the new dataframe
datatrain_sc